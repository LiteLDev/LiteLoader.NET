// 提示文件帮助 Visual Studio IDE 解释 Visual C++ 标识符,
// 如函数和宏的名称。
// 有关详细信息，请参见 https://go.microsoft.com/fwlink/?linkid=865984
#define __ctor(RefClass, NativeClass) RefClass(System::IntPtr p) : ClassTemplate(p) { } RefClass(System::IntPtr p, bool ownsNativeInstance) : ClassTemplate(p, ownsNativeInstance) { } RefClass(NativeClass* p) : ClassTemplate(p) { } RefClass(NativeClass* p, bool ownsNativeInstance) : ClassTemplate(p, ownsNativeInstance) { }
#define __ctor_all(RefClass, NativeClass) __ctor(RefClass, NativeClass); internal: __ctor_copy(RefClass, NativeClass); __ctor_move(RefClass, NativeClass); public:
#define __ctor_base(RefClass, NativeClass, BaseClass) RefClass(System::IntPtr p) : BaseClass(p) { } RefClass(System::IntPtr p, bool ownsNativeInstance) : BaseClass(p, ownsNativeInstance) { } RefClass(NativeClass* p) : BaseClass(p) { } RefClass(NativeClass* p, bool ownsNativeInstance) : BaseClass(p, ownsNativeInstance) { } property NativeClass* NativePtr { public: NativeClass* get() { return static_cast<NativeClass*>(BaseClass::NativePtr); } protected: void set(NativeClass* value) { BaseClass::NativePtr = value; } }
#define __ctor_copy(RefClass, NativeClass) RefClass(NativeClass& r) : ClassTemplate(r) { }
#define __ctor_move(RefClass, NativeClass) RefClass(NativeClass&& m) : ClassTemplate(m) { }
#define NativeCallbackConvertHelper(class_name, callback_delegate, ret, __VA_ARGS__) template <CHash, CHash> ref class NativeCallbackTemplate; template <> ref class NativeCallbackTemplate<do_hash(#class_name) ^ do_hash(#ret), do_hash(#callback_delegate) ^ do_hash(#__VA_ARGS__)> : public NativeCallbackHandler { public: typedef ret (*pCallback)(__VA_ARGS__); delegate ret delCallback(__VA_ARGS__); public: GCHandle gch; callback_delegate ^ delfunc; public: value class Pair { public: pCallback pCallbackFn; NativeCallbackTemplate ^ converter; Pair(pCallback p, NativeCallbackTemplate ^ obj) : pCallbackFn(p) , converter(obj) { } }; protected: NativeCallbackTemplate() : delfunc(nullptr) { } NativeCallbackTemplate(callback_delegate ^ callback) : delfunc(callback) { } ~NativeCallbackTemplate() { this->!NativeCallbackTemplate(); GC::SuppressFinalize(this); } !NativeCallbackTemplate() { if (gch.IsAllocated) gch.Free(); } private: ret NATIVECALLBACK NativeCallbackFunc(__VA_ARGS__); public: static Pair Create(callback_delegate ^ callback) { auto instance = gcnew NativeCallbackTemplate(callback); delCallback ^ del = gcnew delCallback(instance, &NativeCallbackFunc); instance->gch = GCHandle::Alloc(del); auto p = static_cast<pCallback>((void*)Marshal::GetFunctionPointerForDelegate(del)); return Pair(p, instance); } }; ref class class_name : public NativeCallbackTemplate<do_hash(#class_name) ^ do_hash(#ret), do_hash(#callback_delegate) ^ do_hash(#__VA_ARGS__)> { }; ret NativeCallbackTemplate<do_hash(#class_name) ^ do_hash(#ret), do_hash(#callback_delegate) ^ do_hash(#__VA_ARGS__)>::NativeCallbackFunc(__VA_ARGS__)
#define Property_String(nativeName, name) property String^ name { inline String^ get() { return marshalString(_this->nativeName); } inline void set(String^ arg) { _this->nativeName = marshalString(arg); } }
#define Property_Ptr(Namespace, type, nativeName, name) property Namespace::type ^ name { inline Namespace::type ^ get() { return gcnew Namespace::type(_this->nativeName); } inline void set(Namespace::type ^ arg) { _this->nativeName = arg->NativePtr; } }
#define Property(type, nativeName, name) property type name { inline type get() { return _this->nativeName; } inline void set(type arg) { _this->nativeName = arg; } }
#define Property_Instance(Namespace, type, nativeName, name) property Namespace::type ^ name { inline Namespace::type ^ get() { return gcnew Namespace::type(_this->nativeName); } inline void set(Namespace::type ^ arg) { _this->nativeName = arg; } }
#define Property_Enum(type, nativeEnum, name) property type name { inline type get() { return ((type)(_this->m##name)); } inline void set(type arg) { _this->m##name = ((nativeEnum)(arg)); } }
#define ElementTypeImplicit(type) static operator Valuetype ^ (type v) { return gcnew Valuetype(v); }
#define ElementType2Valuetype_Implicit(type) static operator Valuetype ^ (type v) { return gcnew Valuetype(v); }
#define NumberType2Valuetype_Implicit(type) static operator Valuetype ^(type v) { return gcnew Valuetype(gcnew Value(v)); }
#define Valuetype2ElementType(type) static operator type(Valuetype ^ v) { Value ^ val; v->AsValue(val); return (type)val; }
#define Valuetype2ElementType_Implicit(type) static operator type(Valuetype ^ v) { Value ^ val; v->AsValue(val); return (type)val; }
#define Valuetype2List_Implicit(type) static operator List<type> ^ (Valuetype^ v) { auto list = (List<Valuetype^>^)(v); auto ret = gcnew List<type>(list->Count); for each (auto var in list) { ret->Add((type)var); } return ret; }
#define ctor_NumberType(type) Valuetype(List<type>^ v) { auto len = v->Count; std::vector<_T> vec; vec.resize(len); for (int i = 0; i < len; i++) { vec.emplace_back(v[i]); } NativePtr = new _T(std::move(vec)); OwnsNativeInstance = true; };
#define ctor_List_NumberType(type) Valuetype(List<type>^ v) { auto len = v->Count; std::vector<_T> vec; vec.resize(len); for (int i = 0; i < len; i++) { vec.emplace_back(v[i]); } NativePtr = new _T(std::move(vec)); OwnsNativeInstance = true; };
#define List_NumberType2Valuetype(type) static operator Valuetype^ (List<type>^ v) { return gcnew Valuetype(v); };
#define ctor_List_RefType_Ptr(type) Valuetype(List<type>^ v) { auto len = v->Count; std::vector<_T> vec; vec.resize(len); for (int i = 0; i < len; i++) { vec.emplace_back(v[i]->NativePtr); } NativePtr = new _T(std::move(vec)); OwnsNativeInstance = true; };
#define ctor_List_RefType_Instance(type) Valuetype(List<type>^ v) { auto len = v->Count; std::vector<_T> vec; vec.resize(len); for (int i = 0; i < len; i++) { vec.emplace_back(*v[i]->NativePtr); } NativePtr = new _T(std::move(vec)); OwnsNativeInstance = true; };
#define List_Type2Valuetype(type) static operator Valuetype^ (List<type>^ v) { return gcnew Valuetype(v); };
#define NULL_ARG_CHEEK(arg) if (ReferenceEquals(arg, nullptr)) throw gcnew ::System::ArgumentNullException(#arg, "Cannot be null.");
#define Value2SimpleType_Implicit(type) static operator type(Value^ v) { if(v->NativePtr->index() != (size_t)InstanceType::NumberType) throw gcnew LLNET::Core::InvalidRemoteCallTypeException; return std::get<type>(*v->NativePtr); };
#define Valuetype2SimpleType_Implicit(type) static operator type(Valuetype^ v) { return (type)(NumberType)v; };
#define ctor_List_SimpleType(type) Valuetype(List<type>^ v) { auto len = v->Count; std::vector<_T> vec; vec.resize(len); for (int i = 0; i < len; i++) { vec[i] = (v[i]); } NativePtr = new _T(std::move(vec)); OwnsNativeInstance = true; };
#define SimpleType2Valuetype_Implicit(type) static operator Valuetype ^(type v) { return gcnew Valuetype(gcnew Value(v)); }
#define ctor_SimpleType(type) Valuetype(type v) :ClassTemplate(new _T(v), true) {};
#define ctor_Dictionary_NumberType(type) Valuetype(Dictionary<String^, type>^ v) { auto len = v->Count; ::RemoteCall::ValueType::ObjectType umap; for each (auto var in v) { umap.emplace(marshalString(var.Key), var.Value); } NativePtr = new _T(std::move(umap)); OwnsNativeInstance = true; };
#define ctor_Dictionary_RefType_Ptr(type) Valuetype(Dictionary<String^, MC::Player^>^ v) { auto len = v->Count; ::RemoteCall::ValueType::ObjectType umap; for each (auto var in v) { umap.emplace(marshalString(var.Key), _TValue(var.Value->NativePtr)); } NativePtr = new _T(std::move(umap)); OwnsNativeInstance = true; };
#define ctor_Dictionary_RefType_Instance(type) Valuetype(Dictionary<String^, type>^ v) { auto len = v->Count; ::RemoteCall::ValueType::ObjectType umap; for each (auto var in v) { umap.emplace(marshalString(var.Key), _TValue(*(var.Value->NativePtr))); } NativePtr = new _T(std::move(umap)); OwnsNativeInstance = true; };
#define Dictionary_Type2Valuetype(type) static operator Valuetype^ (Dictionary<String^,type>^ v) { return gcnew Valuetype(v); };
#define NATIVECALLBACK
#define Valuetype2Dictionary_SimpleType(type) static operator Dictionary<String^, type> ^ (Valuetype^ v) { auto& umap = std::get<::RemoteCall::ValueType::ObjectType>(v->NativePtr->value); auto ret = gcnew Dictionary<String^, type>((int)umap.size()); for (auto& [k, _v] : umap) { ret->Add(marshalString(k), std::get<double>(std::get<::RemoteCall::Value>(_v.value))); } return ret; };
#define Valuetype2Dictionary_PtrType(type) static operator Dictionary<String^, type^> ^ (Valuetype^ v) { auto& umap = std::get<::RemoteCall::ValueType::ObjectType>(v->NativePtr->value); auto ret = gcnew Dictionary<String^, MC::Player^>((int)umap.size()); for (auto& [k, _v] : umap) { ret->Add(marshalString(k), gcnew MC::Player(std::get<Player*>(std::get<::RemoteCall::Value>(_v.value)))); } return ret; };
#define Valuetype2Dictionary_InstanceType(type, instanceType) static operator Dictionary<String^, type^> ^ (Valuetype^ v) { auto& umap = std::get<::RemoteCall::ValueType::ObjectType>(v->NativePtr->value); auto ret = gcnew Dictionary<String^, type^>((int)umap.size()); for (auto& [k, _v] : umap) { ret->Add(marshalString(k), gcnew type(std::get<instanceType>(std::get<::RemoteCall::Value>(_v.value)))); } return ret; };
#define Property_ValueType(Namespace, type, nativeName, name) property Namespace::type name { inline Namespace::type get() { return Namespace::type(_this->nativeName); } inline void set(Namespace::type arg) { _this->nativeName = arg; } }
#define METHOD_INFO(name, funcname) static initonly MethodInfo^ name = RemoteCallFunctionRegisterBase::typeid->GetMethod(#funcname)
#define __METHOD_INFO(name, funcname) static initonly MethodInfo^ name = RemoteCallFunctionRegisterBase::typeid->GetMethod(#funcname)
#define oc
#define __INLINE [MethodImpl(MethodImplOptions::AggressiveInlining)] inline
#define IEventAPIs virtual property bool IsCancelled; virtual void Cancell() { IsCancelled = true; }
#define EventClass(className) [StructLayout(LayoutKind::Sequential, Size = sizeof(::Event::className))] public value class className
#define CallEventAPI(__VA_ARGS__) static void CallEvent(__VA_ARGS__)
#define _Property_Ptr(Namespace, type, nativeName, name, eventName) property Namespace::type ^ name { inline Namespace::type ^ get() { _PIN_OBJECT(eventName); return gcnew Namespace::type(_THIS(eventName)->nativeName); } inline void set(Namespace::type ^ arg) { _PIN_OBJECT(eventName); _THIS(eventName)->nativeName = arg->NativePtr; } }
#define _Property_String(nativeName, name, eventName) property String^ name { inline String^ get() { _PIN_OBJECT(eventName); return marshalString(_THIS(eventName)->nativeName); } inline void set(String^ arg) { _PIN_OBJECT(eventName); _THIS(eventName)->nativeName = marshalString(arg); } }
#define _Property_Instance(Namespace, type, nativeName, name, eventName) property Namespace::type ^ name { inline Namespace::type ^ get() { _PIN_OBJECT(eventName); return gcnew Namespace::type(_THIS(eventName)->nativeName); } inline void set(Namespace::type ^ arg) { _PIN_OBJECT(eventName); _THIS(eventName)->nativeName = arg; } }
#define _Property(type, nativeName, name, eventName) property type name { inline type get() { _PIN_OBJECT(eventName); return _THIS(eventName)->nativeName; } inline void set(type arg) { _PIN_OBJECT(eventName); _THIS(eventName)->nativeName = arg; } }
#define _Property_Enum(type, nativeEnum, nativeName, name, eventName) property type name { inline type get() { _PIN_OBJECT(eventName); return ((type)(_THIS(eventName)->nativeName)); } inline void set(type arg) { _PIN_OBJECT(eventName); _THIS(eventName)->nativeName = ((nativeEnum)(arg)); } }
#define _Property_ValueType(Namespace, type, nativeName, name, eventName) property Namespace::type name { inline Namespace::type get() { _PIN_OBJECT(eventName); return Namespace::type(_THIS(eventName)->nativeName); } inline void set(Namespace::type arg) { _PIN_OBJECT(eventName); _THIS(eventName)->nativeName = arg; } }
#define CallEventAPI_Imp(_event, __VA_ARGS__) void _event::CallEvent(__VA_ARGS__)
#define NativeCallback(eventName) delegate bool _delNativeCallback(::Event::eventName&); static bool _nativeCallback(::Event::eventName& ev) { auto% _ev = *(eventName*)&ev; EventManager::CallNativeEventInternal(_ev, EventId); return !_ev.IsCancelled; } static eventName() { auto delfunc = gcnew _delNativeCallback(&_nativeCallback); GCHandle::Alloc(delfunc); ::Event::eventName::subscribe_ref( static_cast<bool(*)(::Event::eventName&)>( (void*)Marshal::GetFunctionPointerForDelegate(delfunc))); }
#define __ctor_all_base(RefClass, NativeClass, BaseClass) __ctor_base(RefClass, NativeClass, BaseClass); internal: __ctor_copy_base(RefClass, NativeClass, BaseClass); __ctor_move_base(RefClass, NativeClass, BaseClass); public:
#define __ref_class public ref class
#define __static abstract sealed